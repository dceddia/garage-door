var gpio = require('gpio');
var exec = require('child_process').exec;
var q = require('q');
var util = require('util');
var EventEmitter = require('events').EventEmitter;

gpio.logging = true;

var stateChangeFn = function() {};

// BCM pin numbers
var PIN_OPEN = 18;
var PIN_CLOSED = 14;
var PIN_RELAY = 15;

// These map to GPIO pins on the Pi
var open_sensor;
var closed_sensor;
var relay;

var open_sensor_ready = false;
var closed_sensor_ready = false;

var door_state = "unknown";

var initialized = false;

function debug() {
  console.log.apply(console, arguments);
}

function initOpenSensor() {
  // Setup the pin for reading the "open" hall sensor
  var open_ready = q.defer();
  debug('[pin_open] initializing...');
  open_sensor = gpio.export(PIN_OPEN, { 
      direction: 'in',
      invert: true,
      ready: function() {
        debug('[pin_open] ready');
        open_ready.resolve();
      }
  });

  return open_ready.promise;
}

function initClosedSensor() {
  // Setup the pin for reading the "closed" hall sensor
  var closed_ready = q.defer();
  debug('[pin_closed] initializing...');
  closed_sensor = gpio.export(PIN_CLOSED, {
      direction: 'in',
      invert: true,
      ready: function() {
        closed_ready.resolve();
        debug('[pin_closed] ready');
      }
  });

  return closed_ready.promise;
}

function readInitialSensorValues() {
  debug('Reading initial sensor values...');
  // Read the value of the 'open' sensor
  var open_value = q.defer();
  open_sensor.get(function(val) {
    debug('[pin_open] value = ', val);
    open_value.resolve(val);
  });

  // Read the value of the 'closed' sensor
  var closed_value = q.defer();
  closed_sensor.get(function(val) {
    debug('[pin_closed] value = ', val);
    closed_value.resolve(val);
  });

  // Once both values are resolved, then resolve this promise
  return q.all([open_value.promise, closed_value.promise]);
}

function setInitialState(pin_values) {
  var open_state = pin_values[0];
  var closed_state = pin_values[1];

  debug('Setting initial state based on (pin_open: ', open_state, ', pin_closed: ', closed_state, ')');

  // Door state will be 'unknown' unless one (and only one) of the
  // sensors is reading high.
  door_state = 'unknown';
  if(open_state && !closed_state) {
    door_state = 'open';
  } else if(closed_state && !open_state) {
    door_state = 'closed';
  }

  debug('Initial state:  ', door_state);
}

function watchForChanges() {
  debug('Watching for changes...');

  // Watch for changes and notify listeners.
  open_sensor.on('change', function(val) {
    // If sensor goes high, door is definitely open
    // If sensor goes low, door is probably closing
    var last_state = door_state;
    if(val) {
      door_state = 'open';
    } else {
      door_state = 'closing';
    }
    debug('[pin_open] changed to ', val, '. door_state:  "', last_state, '" -> "', door_state, '"');
    stateChangeFn(last_state, door_state);
  });

  closed_sensor.on('change', function(val) {
    // If sensor goes high, door is definitely closed
    // If sensor goes low, door is probably opening
    var last_state = door_state;
    if(val) {
      door_state = 'closed';
    } else {
      door_state = 'opening';
    }
    debug('[pin_closed] changed to ', val, '. door_state:  "', last_state, '" -> "', door_state, '"');
    stateChangeFn(last_state, door_state);
  }); 
}

function initRelay() {
  debug('[relay] initializing...');
  // Setup the pin for controlling the relay which activates the door
  relayOff();
  exec('gpio -g mode ' + PIN_RELAY + ' out', function() {
        debug('[relay] ready');
  });
}

// The relay is sort of backwards
// (0) means on
// (1) means off
function relayOn() {
  debug('[relay] ON');
  exec('gpio -g write ' + PIN_RELAY + ' 0');
}
function relayOff() {
  debug('[relay] OFF');
  exec('gpio -g write ' + PIN_RELAY + ' 1');
}

var _init = function() {
  initRelay();

  q.all([initOpenSensor(), initClosedSensor()])
   .then(readInitialSensorValues)
   .then(setInitialState)
   .then(function() { initialized = true; })
   .then(watchForChanges);
};

var _state = function() {
	return door_state;
};

var _on_change = function(callback) {
	stateChangeFn = callback;
};

// Turn the relay on, then off again
var _activate = function() {
  debug('[activate]');
	relayOn();

  // Activating the relay makes the door start/stop moving
  // Update the state accordingly
  var last_state = door_state;
  switch(door_state) {
    case 'open':
      // The state will update when the 'open' sensor changes
      break;
    case 'opening':
      door_state = 'stopped';
      break;
    case 'closing':
      door_state = 'opening';
      break;
    case 'closed':
      // The state will update when the 'closed' sensor changes
      break;
    case 'stopped':
      door_state = 'closing';
      break;
  }
  debug('[activate] door_state:  ', last_state, ' -> ', door_state);
  stateChangeFn(last_state, door_state);

	setTimeout(function() {
		relayOff();
	}, 800);
};

var DoorCtrl = function() {
  var self = this;

  if(!initialized) {
    _init();

    stateChangeFn = function(oldValue, newValue) {
      self.emit('change', oldValue, newValue);
    };

    self.state = function() {
      return door_state;
    };
  }
};

util.inherits(DoorCtrl, EventEmitter);

DoorCtrl.prototype.activate = function() {
  _activate();
};

module.exports = function() { return new DoorCtrl(); };
